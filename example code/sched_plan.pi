
% constraints
% 
% NWeeks: number of weeks to schedule
% JobsPeople: which person can do a job
% Works with: who wants to work with who
% MaxJobs: maximum jobs a person can work overall
% 
% We use global_map to avoid passing all the globals as arguments

import planner.
import cp.
% import util. 

main => 
    
    
    % constraints
    NWeeks      = 7,
    People      = ["Nobody", "Alice","Bob","Carol","David","Emily","Frank","George" ],
    MaxJobs     = [ 2000   , 20     , 20  , 30    , 30    , 30    , 3     , 100      ],
    Jobs        = ["Piano","Prayer","Video","Clean"],
    JobsPeople  = [[2]  , [3,4,5,6]    , [5,6] , [2,3,4,5,6,7,8]],
    WorksWith   = [[2,3,2],[3,2,100]], % person index 1 asks to work with person index 2, cost is index 3
    CantWork    = [[2,1]], % person index 1 can't work week index 2

    % put constrains into global map
    Globals = get_global_map(),
    Globals.put(people,People),
    Globals.put(jobs,Jobs),
    Globals.put(nweeks,NWeeks),
    Globals.put(maxjobs,MaxJobs),
    Globals.put(jobpeople,JobsPeople),
    Globals.put(workswith,WorksWith),
    Globals.put(cantwork,CantWork),
    
    % Initial =  [Week, [Job Assigns], [Total Assigned]]
    InitialAssignment = [0,new_list(NWeeks,0),new_list(People.len,0)], 
    time(best_plan(InitialAssignment,Plan,Cost)),
    foreach (I in 1..Plan.len),
        printf("Week %w: %w\n",I,Plan[I])
    end,
    print_sched(Plan,People,Jobs),

    println(cost=Cost).

final(S@[Week,Assigns,TotalAssigned]) => 
    Globals = get_global_map(),
    Week == Globals.get(nweeks), % end when nweeks is reached
    true.

% final(S@[Week,Assigns,TotalAssigned],Plan,Cost) =>
%     Plan = [],
%     Cost = 0,
 % we could add a constraint on the whole plan here via CurPlan
%     current_plan() = CurPlan,
%     println(fcurplan=CurPlan),
%     println(fp=Plan),
%     println(fcost=Cost),
%     println(fs=S),
%     Globals = get_global_map(),
%     println(Globals.get(nweeks)),
%     Week == Globals.get(nweeks),
%     true.


action(S@[Week,Assigns,TotalAssigned],NextS,Action,Cost) =>
    % println(s=S),

    Globals     = get_global_map(),
    People      = Globals.get(people),
    Jobs        = Globals.get(jobs),
    NWeeks      = Globals.get(nweeks),
    MaxJobs     = Globals.get(maxjobs),
    JobsPeople  = Globals.get(jobpeople),
    WorksWith   = Globals.get(workswith),
    CantWork    = Globals.get(cantwork),

    NextAssigns = new_list(Jobs.len),
    NextTotal = copy_term(TotalAssigned),

    NewCost = 1,

    % assign jobs
    foreach (I in 1..Jobs.len)
        % assign based on skills
        (member(NextAssigns[I],JobsPeople[I]); NextAssigns[I]=1),

        % penalty for two weeks in a row
        if NextAssigns[I] == Assigns[I] then NewCost := NewCost + 1 end,

        % cant work penalty
        foreach (CW in CantWork)
            if (membchk(CW[1], NextAssigns), CW[2]==Week+1) then NewCost := NewCost + 10 end
        end,

        if NextAssigns[I] == 1 then NewCost := NewCost + 5 end,

        NextTotal[NextAssigns[I]] :=  1 + TotalAssigned[NextAssigns[I]],
    end,

    % this could also be expressed as a penalty
    all_different(NextAssigns), % different people for each job, from cp

    % penalty for more than MaxJobs
    foreach (I in 1..People.len)
        if NextTotal[I] > MaxJobs[I] then NewCost := NewCost + 1 end,
        
        % works with penalty
        foreach (W in WorksWith)
        if (membchk(W[1], NextAssigns), not(membchk(W[2], NextAssigns)) )
                then NewCost := NewCost + W[3] end
        end
    end,


    Action = NextAssigns,
    NextS = [Week+1,NextAssigns,NextTotal],
    Cost = NewCost.


% print_sched(Schedule,People,Jobs).

print_sched(S,People,Jobs) =>
    printf("\t"),
    foreach (I in 1..S.len)
        printf("Week %w\t",I)
    end,
    printf("\n"),
    foreach (I in 1..S[1].len)
        printf("%w\t",Jobs[I]),
        foreach (J in 1..S.len)
            printf("%w\t",People[S[J,I]])
        end,
        printf("\n")
    end.